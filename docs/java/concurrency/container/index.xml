<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>并发容器 on IWiki</title>
    <link>https://jiandar.github.io/docs/java/concurrency/container/</link>
    <description>Recent content in 并发容器 on IWiki</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://jiandar.github.io/docs/java/concurrency/container/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ThreadLocal</title>
      <link>https://jiandar.github.io/docs/java/concurrency/container/ThreadLocal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiandar.github.io/docs/java/concurrency/container/ThreadLocal/</guid>
      <description>ThreadLocal#概述# 线程本地变量 变量在每个线程中都有独立拷贝，线程对变量的访问都是基于它自己的变量，就避免了线程不安全问题  原理# 每个 Thread 对象都有一个 ThreadLocalMap 映射表 ThreadLocalMap 的 key 是 ThreadLocal 实例本身，value 则存储 Object 数据 通过 ThreadLocal 对象的 get()/set() 方法进行取值/设值  方法#// 构造方法 public ThreadLocal() // 设值 public void set(T value) // 取值 public T get() 示例#public class Test { private static ThreadLocal&amp;lt;String&amp;gt; local = new ThreadLocal&amp;lt;&amp;gt;(); public static void main(String[] args) { String[] values = {&amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;3&amp;#34;, &amp;#34;4&amp;#34;, &amp;#34;5&amp;#34;}; for (String value : values) { new Thread(() -&amp;gt; { String thread = Thread.</description>
    </item>
    
    <item>
      <title>BlockingQueue</title>
      <link>https://jiandar.github.io/docs/java/concurrency/container/BlockingQueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiandar.github.io/docs/java/concurrency/container/BlockingQueue/</guid>
      <description>BlockingQueue#阻塞队列# 队列，Queue，是一种先进先出（first in first out：FIFO）的抽象的数据结构 BlockingQueue，是一个支持两个附加操作的队列 当阻塞队列是空时，从队列中获取元素的操作将会被阻塞 当阻塞队列是满时，往队列中添加元素的操作将会被阻塞  核心方法#    抛出异常 返回特殊值 超时退出 一直阻塞     插入 add(e) offer(e) offer(e,time,unit) put(e)   移除 remove() poll() poll(time,unit) take()   检查 element() peek() / /        说明     抛出异常 当阻塞队列满时，再往队列 add 元素会抛 IllegalStateException:Queuefull当阻塞队列空时，再往队列 Remove 元素时候会抛出 NoSuchElementException   返回特殊值 插入方法，成功返回 true，失败返回 false移除方法，成功返回元素，队列里面没有就返回null   超时退出 当阻塞队列满时，队列会阻塞生产者线程一定时间，超过时限后生产者线程就会退出当阻塞队列空时，队列会阻塞消费者线程一定时间，超过时限后消费者线程就会退出   一直阻塞 当阻塞队列满时，生产者继续往队列里面 put 元素，队列会一直阻塞，直到 put 数据 or 响应中断退出当阻塞队列空时，消费者试图从队列 take 元素，队列会一直阻塞消费者线程，直到队列可用    常用队列#   队列 说明 实现     ArrayBlockingQueue 有界阻塞队列 由数组实现   LinkedBlockingQueue 有界阻塞队列 由链表实现   LinkedTransferQueue 无界阻塞队列 由链表实现   LinkedBlockingDeque 双端有界阻塞队列 由链表实现   DelayQueue 延迟无界阻塞队列    SynchronousQueue 单元素的阻塞队列    PriorityBlockingQueue 支持优先级的无界阻塞队列     应用# 线程池、消息中间件、生产者消费者模式  // 生产者消费者模式-传统版 public class ShareData { private int num = 0; private Lock lock = new ReentrantLock(); private Condition condition = lock.</description>
    </item>
    
    <item>
      <title>ConcurrentHashMap</title>
      <link>https://jiandar.github.io/docs/java/concurrency/container/ConcurrentHashMap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiandar.github.io/docs/java/concurrency/container/ConcurrentHashMap/</guid>
      <description>ConcurrentHashMap#ConcurrentHashMap</description>
    </item>
    
    <item>
      <title>CopyOnWriteArrayList</title>
      <link>https://jiandar.github.io/docs/java/concurrency/container/CopyOnWriteArrayList/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiandar.github.io/docs/java/concurrency/container/CopyOnWriteArrayList/</guid>
      <description>CopyOnWriteArrayList#设计思想# Copy-On-Write（COW），是一种读写分离的思想 写线程写入数据的时候，会复制新建一个新容器。当数据更新完成后，再将旧容器引用指向新容器。 读线程感知数据更新是延时的，牺牲了数据实时性而保证数据最终一致性。 由于写线程写数据是在新容器写入的，因此读线程不会被阻塞。  应用场景# 适用于读多写少的场景，比如系统的黑名单白名单设置  代码实现# array  private transient volatile Object[] array;  get  public E get(int index) { return get(getArray(), index); } final Object[] getArray() { return array; } private E get(Object[] a, int index) { return (E) a[index]; }  add  public boolean add(E e) { final ReentrantLock lock = this.</description>
    </item>
    
  </channel>
</rss>
